package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG,BREAK,CLASS,ENUM,ELSE,CONST,IF,DO,WHILE,NEW,PRINT,READ,RETURN,VOID,EXTENDS,CONTINUE,THIS,SUPER,RECORD,INSTANCEOF,INC,DEC,ADD,SUB,MUL,DIV,MOD,EXP,EQ,NEQ,GTE,GT,LTE,LT,AND,OR,ASSIGN,SEMICOLON,COLON,COMMA,VARARGS,DOT,LPAREN,RPAREN,LBRACKET,RBRACKET,LBRACE,RBRACE;
terminal String IDENT;
terminal Integer NUMBER;
terminal Boolean BOOL;
terminal Character CHAR;

nonterminal Program;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgramDecl;
nonterminal DeclList;
nonterminal Decl;
nonterminal MethodDeclList;
nonterminal ConstDecl;
nonterminal VarDecl;
nonterminal ClassDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj ClassDeclStart;
nonterminal ClassVarDeclList;
nonterminal RecordDecl;
nonterminal RecordDeclStart;
nonterminal rs.etf.pp1.symboltable.concepts.Struct Type;
nonterminal ConstAssignment;
nonterminal ConstAssignmentList;
nonterminal Literal;
nonterminal Var;
nonterminal VarList;
nonterminal VarDeclList;
nonterminal Brackets;
nonterminal Extends;
nonterminal ConstructorDeclAndMethodDeclListWrapper;
nonterminal ConstructorDeclAndMethodDeclList;
nonterminal ConstructorDecl;
nonterminal StatementList;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDecl;
nonterminal rs.etf.pp1.symboltable.concepts.Obj MethodDeclStart;
nonterminal TypeOrVoid;
nonterminal FormPars;
nonterminal FormParList;
nonterminal FormPar;
nonterminal Statement;
nonterminal MatchedStatement;
nonterminal UnmatchedStatement;
nonterminal Condition;
nonterminal Designator;
nonterminal DesignatorOperation;
nonterminal CondTerm;
nonterminal CondFact;
nonterminal Expr;
nonterminal OrCondTermList;
nonterminal AndCondFactList;
nonterminal RelopExpr;
nonterminal Term;
nonterminal AddopTermList;
nonterminal Addop;
nonterminal Relop;
nonterminal Mulop;
nonterminal Assignop;
nonterminal Expop;
nonterminal Factor;
nonterminal MulopFactorList;
nonterminal BaseExp;
nonterminal ExpopBaseExpList;
nonterminal ActParsOrNothing;
nonterminal BracketsWithExprOrNothing;
nonterminal FuncCallOrNothing;
nonterminal ExprList;
nonterminal VarArgs;
nonterminal ExprOrNothing;
nonterminal NumConstList;
nonterminal FormParsOrError;
nonterminal ConditionOrError;

Program ::=
    (Program)
    ProgramDecl DeclList LBRACE MethodDeclList RBRACE;

ProgramDecl ::=
    (ProgramDecl)
    PROG IDENT:ident;

DeclList ::=
    (DeclListIndeed)
    DeclList Decl
    |
    (NoDeclList)
    /* Ɛ */;

Decl ::=
    (ConstDeclaration)
    ConstDecl
    |
    (VarDeclaration)
    VarDecl
    |
    (ClassDeclaration)
    ClassDecl
    |
    (RecordDeclarataion)
    RecordDecl;

RecordDecl ::=
    (RecordDecl)
    RecordDeclStart LBRACE VarDeclList RBRACE;

RecordDeclStart ::=
    (RecordDeclStart)
    RECORD IDENT:ident;

ConstDecl ::=
    (ConstDecl)
    CONST Type:type ConstAssignment ConstAssignmentList SEMICOLON
//  |
//    (ConstDeclError)
//    CONST error SEMICOLON:l
//    {: parser.report_error("SYNTAX ERROR: one or more invalid const declarations on line: " + lleft , null); :}
    ;

ConstAssignment ::=
    (ConstAssignment)
    IDENT:ident ASSIGN Literal;

ConstAssignmentList ::=
    (ConstAssignmentListIndeed)
    ConstAssignmentList COMMA ConstAssignment
    |
    (NoConstAssignmentList)
    /* Ɛ */;

NumConstList ::=
    (NumConstListIndeed)
    NumConstList COMMA NUMBER
    |
    /* Ɛ */;

Literal ::=
    (NumConst)
    NUMBER:numVal
    |
    (CharConst)
    CHAR:charVal
    |
    (BoolConst)
    BOOL:boolVal;

Type ::=
    (Type)
    IDENT:ident
    ;

TypeOrVoid ::=
    (TypeOrVoid_Type)
    Type:type
    |
    (TypeOrVoid_Void)
    VOID;

VarDecl ::=
    (VarDeclValid)
    Type Var VarList SEMICOLON
    |
    (VarDeclErrorCommaRecovery)
    error COMMA:l
    {: parser.report_error("SYNTAX ERROR: one or more invalid var declarations on line: " + lleft , null); :}
    |
    (VarDeclErrorSemicolonRecovery)
    error SEMICOLON:l
    {: parser.report_error("SYNTAX ERROR: one or more invalid var declarations on line: " + lleft , null); :};


Var ::=
    (Var)
    IDENT:ident Brackets
    ;

Brackets ::=
    (BracketsIndeed)
    LBRACKET RBRACKET
    |
    (NoBrackets)
    /* Ɛ */;

VarList ::=
    (VarListIndeed)
    VarList COMMA Var
    |
    (NoVarList)
    /* Ɛ */;

VarDeclList ::=
    (VarDeclListIndeed)
    VarDeclList VarDecl
    |
    (NoVarDeclList)
    /* Ɛ */;

ClassDecl ::=
    (ClassDeclValid)
    ClassDeclStart Extends LBRACE ClassVarDeclList ConstructorDeclAndMethodDeclListWrapper RBRACE
    |
    (ClassDeclError)
    ClassDeclStart EXTENDS error:l {: parser.report_error("SYNTAX ERROR: invalid EXTENDS syntax on line: " + lleft , null); :}
    LBRACE VarDeclList ConstructorDeclAndMethodDeclListWrapper RBRACE
    ;

ClassDeclStart ::=
    (ClassDeclStart)
    CLASS IDENT:ident
    ;

ClassVarDeclList ::=
    (ClassVarDeclList)
    VarDeclList
    ;

Extends ::=
    (ExtendsIndeed)
    EXTENDS Type:ident
    |
    (NoExtends)
    /* Ɛ */;

ConstructorDeclAndMethodDeclListWrapper ::=
    (ConstructorDeclAndMethodDeclListWrapperIndeed)
    LBRACE ConstructorDeclAndMethodDeclList RBRACE
    |
    (NoConstructorDeclAndMethodDeclListWrapper)
    /* Ɛ */;

ConstructorDeclAndMethodDeclList ::=
    (ConstructorAndMethodDeclListIndeed)
    ConstructorDecl MethodDeclList
    |
    (MethodDeclListWithoutConstructorDecl)
    MethodDeclList;

ConstructorDecl ::=
    (ConstructorDecl)
    IDENT:ident LPAREN RPAREN VarDeclList LBRACE StatementList RBRACE;

MethodDeclList ::=
    (MethodDeclListIndeed)
    MethodDecl MethodDeclList
    |
    (NoMethodDeclList)
    /* Ɛ */;

MethodDecl ::=
    (MethodDecl)
    TypeOrVoid MethodDeclStart FormParsOrError VarDeclList LBRACE StatementList RBRACE;

MethodDeclStart ::=
    (MethodDeclStart)
    IDENT:ident;

FormParsOrError ::=
    (FormParsFormPars)
    LPAREN FormPars RPAREN
    |
    (FormParsErrorRPAREN)
    LPAREN error:l {: parser.report_error("SYNTAX ERROR: one or more invalid formal parameter declarations on line: " + lleft , null); :} RPAREN
    ;

FormPars ::=
    (MultipleFormPars)
    FormParList COMMA FormPar
    |
    (MultipleFormParsAndVarArgs)
    FormParList COMMA VarArgs
    |
    (FormParsErrorCOMMA)
    error:l {: parser.report_error("SYNTAX ERROR: one or more invalid formal parameter declarations on line: " + lleft , null); :} COMMA
    |
    (SingleFormPar)
    FormPar
    |
    (SingleVarArg)
    VarArgs
    |
    (NoFormPars)
    /* Ɛ */;

FormParList ::=
    (FormParListMultiple)
    FormParList COMMA FormPar
    |
    (FirstFormPar)
    FormPar;

FormPar ::=
    (FormPar)
    Type:type IDENT:ident Brackets;

VarArgs ::=
    (VarArgs)
    Type:type VARARGS IDENT:ident;

StatementList ::=
    (StatementListIndeed)
    StatementList Statement
    |
    (NoStatementList)
    /* Ɛ */;

Statement ::=
    (StatementMatchedStatement)
    MatchedStatement
    |
    (StatementUnmatchedStatement)
    UnmatchedStatement;

MatchedStatement ::=
    (MatchedIfStatement)
    IF ConditionOrError MatchedStatement ELSE MatchedStatement
    |
    (BodyStatement)
    LBRACE StatementList RBRACE
    |
    (DesignatorStatement)
    Designator DesignatorOperation SEMICOLON
    |
    (DesignatorAssignStatementError)
    Designator Assignop error:l {: parser.report_info("SYNTAX ERROR: one or more invalid assign operations on line: " + lleft, null); :} SEMICOLON
    |
    (DoWhileStatement)
    DO StatementList WHILE LPAREN Condition RPAREN SEMICOLON
    |
    (BreakStatement)
    BREAK SEMICOLON
    |
    (ContinueStatement)
    CONTINUE SEMICOLON
    |
    (ReturnStatement)
    RETURN ExprOrNothing SEMICOLON
    |
    (ReadStatement)
    READ LPAREN Designator RPAREN SEMICOLON
    |
    (PrintStatement)
    PRINT LPAREN Expr NumConstList RPAREN SEMICOLON;

UnmatchedStatement ::=
    (UnmatchedIfStatement)
    IF ConditionOrError Statement
    |
    (UnmatchedIfElseStatement)
    IF ConditionOrError MatchedStatement ELSE UnmatchedStatement;

ConditionOrError ::=
    (ConditionValid)
    LPAREN Condition RPAREN
    |
    (ConditionError)
    LPAREN error:l {: parser.report_info("SYNTAX ERROR: one or more invalid assign operations on line: " + lleft, null); :} RPAREN;

DesignatorOperation ::=
    (DesignatorAssignOperation)
    Assignop Expr
    |
    (DesignatorFuncCallOperation)
    LPAREN ActParsOrNothing RPAREN
    |
    (DesignatorIncOperation)
    INC
    |
    (DesignatorDecOperation)
    DEC;

ActParsOrNothing ::=
    (ActPars)
    Expr ExprList
    |
    (NoActPars)
    /* Ɛ */;

ExprList ::=
    (ExprListIndeed)
    ExprList COMMA Expr
    |
    (NoExprList)
    /* Ɛ */;

ExprOrNothing ::=
    (ExprIndeed)
    Expr
    |
    /* Ɛ */;

Designator ::=
    (DesignatorMemberReference)
    Designator DOT IDENT
    |
    (DesignatorArrayReference)
    Designator LBRACKET Expr RBRACKET
    |
    (DesignatorIdent)
    IDENT:ident;

Condition ::=
    (Condition)
    CondTerm OrCondTermList;

CondTerm ::=
    (CondTerm)
    CondFact AndCondFactList;

OrCondTermList ::=
    (OrCondTermListIndeed)
    OrCondTermList OR CondTerm
    |
    (NoOrCondTermList)
    /* Ɛ */;

AndCondFactList ::=
    (AndCondFactListIndeed)
    AndCondFactList AND CondFact
    |
    (NoAndCondTermList)
    /* Ɛ */;

CondFact ::=
    (ExprCondFact)
    Expr RelopExpr
    |
    (InstanceOfCondFact)
    Designator INSTANCEOF Type:type;

RelopExpr ::=
    (RelopExprIndeed)
    Relop Expr
    |
    (NoRelopExpr)
    /* Ɛ */;

Expr ::=
    (NegativeExpr)
    SUB Term AddopTermList
    |
    (PositiveExpr)
    Term AddopTermList;

Term ::=
    (Term)
    Factor MulopFactorList;

MulopFactorList ::=
    (MulopFactorListIndeed)
    MulopFactorList Mulop Factor
    |
    (NoMulopFactorList)
    /* Ɛ */;

Factor ::=
    (Factor)
    BaseExp ExpopBaseExpList;

ExpopBaseExpList ::=
    (ExpopBaseExpListIndeed)
    ExpopBaseExpList Expop BaseExp
    |
    (NoExpopBaseExpList)
    /* Ɛ */;

BaseExp ::=
    (BaseExpDesignator)
    Designator FuncCallOrNothing
    |
    (BaseExpNumber)
    NUMBER
    |
    (BaseExpChar)
    CHAR
    |
    (BaseExpBool)
    BOOL
    |
    (BaseExpNewInstance)
    NEW Type BracketsWithExprOrNothing
    |
    (BaseExpExpr)
    LPAREN Expr RPAREN;

FuncCallOrNothing ::=
    (FuncCall)
    LPAREN ActParsOrNothing RPAREN
    |
    (NoFuncCall)
    /* Ɛ */;

BracketsWithExprOrNothing ::=
    (BracketsWithExpr)
    LBRACKET Expr RBRACKET
    |
    (NoBracketsWithExpr)
    /* Ɛ */;

AddopTermList ::=
    (AddopTermListIndeed)
    AddopTermList Addop Term
    |
    (NoAddopTermList)
    /* Ɛ */;

Addop ::=
    (Add)
    ADD
    |
    (Sub)
    SUB;

Assignop ::=
    (Assign)
    ASSIGN;

Relop ::=
    (Eq)
    EQ
    |
    (Neq)
    NEQ
    |
    (Gt)
    GT
    |
    (Gte)
    GTE
    |
    (Lt)
    LT
    |
    (Lte)
    LTE;

Mulop ::=
    (Mul)
    MUL
    |
    (Div)
    DIV
    |
    (Mod)
    MOD;

Expop ::=
    (Exp)
    EXP;

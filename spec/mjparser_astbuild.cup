package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:

	boolean errorDetected = false;

	Logger log = Logger.getLogger(getClass());


    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke

    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }

    public void syntax_error(Symbol cur_token) {
        report_error("\nSintaksna greska", cur_token);
    }

    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatalna greska, parsiranje se ne moze nastaviti", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.error(msg.toString());
    }

    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message);
    	if (info instanceof Symbol)
            msg.append (" na liniji ").append(((Symbol)info).left);
        log.info(msg.toString());
    }

:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null)
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}


terminal PROG,BREAK,CLASS,ENUM,ELSE,CONST,IF,DO,WHILE,NEW,PRINT,READ,RETURN,VOID,EXTENDS,CONTINUE,THIS,SUPER,RECORD,INSTANCEOF,INC,DEC,ADD,SUB,MUL,DIV,MOD,EXP,EQ,NEQ,GTE,GT,LTE,LT,AND,OR,ASSIGN,SEMICOLON,COLON,COMMA,VARARGS,DOT,LPAREN,RPAREN,LBRACKET,RBRACKET,LBRACE,RBRACE,NUMBER,BOOL,CHAR,IDENT;

nonterminal Program Program;
nonterminal DeclList DeclList;
nonterminal Decl Decl;
nonterminal MethodDeclList MethodDeclList;
nonterminal ConstDecl ConstDecl;
nonterminal VarDecl VarDecl;
nonterminal ClassDecl ClassDecl;
nonterminal RecordDecl RecordDecl;
nonterminal Type Type;
nonterminal ConstAssignment ConstAssignment;
nonterminal ConstAssignmentList ConstAssignmentList;
nonterminal Literal Literal;
nonterminal Var Var;
nonterminal VarList VarList;
nonterminal VarDeclList VarDeclList;
nonterminal Brackets Brackets;
nonterminal Extends Extends;
nonterminal ConstructorDeclAndMethodDeclListWrapper ConstructorDeclAndMethodDeclListWrapper;
nonterminal ConstructorDeclAndMethodDeclList ConstructorDeclAndMethodDeclList;
nonterminal ConstructorDecl ConstructorDecl;
nonterminal StatementList StatementList;
nonterminal MethodDecl MethodDecl;
nonterminal TypeOrVoid TypeOrVoid;
nonterminal FormPars FormPars;
nonterminal FormParList FormParList;
nonterminal FormPar FormPar;
nonterminal Statement Statement;
nonterminal MatchedStatement MatchedStatement;
nonterminal UnmatchedStatement UnmatchedStatement;
nonterminal Condition Condition;
nonterminal Designator Designator;
nonterminal DesignatorOperation DesignatorOperation;
nonterminal CondTerm CondTerm;
nonterminal CondFact CondFact;
nonterminal Expr Expr;
nonterminal OrCondTermList OrCondTermList;
nonterminal AndCondFactList AndCondFactList;
nonterminal RelopExpr RelopExpr;
nonterminal Term Term;
nonterminal AddopTermList AddopTermList;
nonterminal Addop Addop;
nonterminal Relop Relop;
nonterminal Mulop Mulop;
nonterminal Assignop Assignop;
nonterminal Expop Expop;
nonterminal Factor Factor;
nonterminal MulopFactorList MulopFactorList;
nonterminal BaseExp BaseExp;
nonterminal ExpopBaseExpList ExpopBaseExpList;
nonterminal ActParsOrNothing ActParsOrNothing;
nonterminal BracketsWithExprOrNothing BracketsWithExprOrNothing;
nonterminal FuncCallOrNothing FuncCallOrNothing;
nonterminal ExprList ExprList;
nonterminal VarArgs VarArgs;
nonterminal ExprOrNothing ExprOrNothing;
nonterminal NumConstList NumConstList;
nonterminal FormParsOrError FormParsOrError;
nonterminal ConditionOrError ConditionOrError;

Program ::=
    (Program)
    PROG IDENT:ident DeclList:D1 LBRACE MethodDeclList:M2 RBRACE {: RESULT=new Program(D1, M2); RESULT.setLine(D1left); :};

DeclList ::=
    (_DeclList)
    DeclList Decl
    |
    (NoDeclList)
    /* Æ? */;

Decl ::=
    (ConstDeclaration)
    ConstDecl:C1 {: RESULT=new ConstDeclaration(C1); RESULT.setLine(C1left); :}
    |
    (VarDeclaration)
    VarDecl:V1 {: RESULT=new VarDeclaration(V1); RESULT.setLine(V1left); :}
    |
    (ClassDeclaration)
    ClassDecl:C1 {: RESULT=new ClassDeclaration(C1); RESULT.setLine(C1left); :}
    |
    (RecordDeclarataion)
    RecordDecl:R1 {: RESULT=new RecordDeclarataion(R1); RESULT.setLine(R1left); :};

RecordDecl ::=
    (RecordDecl)
    RECORD IDENT:ident LBRACE VarDeclList:V1 RBRACE {: RESULT=new RecordDecl(V1); RESULT.setLine(V1left); :};

ConstDecl ::=
    (_ConstDecl)
    CONST Type:type ConstAssignment ConstAssignmentList SEMICOLON
//  |
//    (ConstDeclError)
//    CONST error SEMICOLON:l
//    {: parser.report_error("SYNTAX ERROR: one or more invalid const declarations on line: " + lleft , null); :}
    ;

ConstAssignment ::=
    (ConstAssignment)
    IDENT:ident ASSIGN Literal:L1 {: RESULT=new ConstAssignment(L1); RESULT.setLine(L1left); :};

ConstAssignmentList ::=
    (_ConstAssignmentList)
    ConstAssignmentList COMMA ConstAssignment
    |
    (NoConstAssignmentList)
    /* Æ? */;

NumConstList ::=
    (_NumConstList)
    NumConstList COMMA NUMBER
    |
    /* Æ? */;

Literal ::=
    (NumConst)
    NUMBER:numVal {: RESULT=new NumConst(); :}
    |
    (CharConst)
    CHAR:charVal {: RESULT=new CharConst(); :}
    |
    (BoolConst)
    BOOL:boolVal {: RESULT=new BoolConst(); :};

Type ::=
    (Type)
    IDENT:ident {: RESULT=new Type(); :};

TypeOrVoid ::=
    (TypeOrVoid_Type)
    Type:type
    (TypeOrVoid_Void)
    |
    VOID; {: RESULT=new TypeOrVoid_Type(Type); RESULT.setLine(Typeleft); :} {: RESULT=new TypeOrVoidDerived1(); :}

VarDecl ::=
    (_VarDecl)
    Type:type Var VarList SEMICOLON
    |
    (VarDeclErrorSemicolonRecovery)
    error COMMA:l
    {: parser.report_error("SYNTAX ERROR: one or more invalid var declarations on line: " + lleft , null); :}
    |
    (VarDeclErrorSemicolonRecovery)
    error SEMICOLON:l
    {: parser.report_error("SYNTAX ERROR: one or more invalid var declarations on line: " + lleft , null); :};

Var ::=
    (Var)
    IDENT:ident Brackets:B1 {: RESULT=new Var(B1); RESULT.setLine(B1left); :};

Brackets ::=
    (_Brackets)
    LBRACKET RBRACKET
    |
    (NoBrackets)
    /* Æ? */;

VarList ::=
    (_VarList)
    VarList COMMA Var
    |
    (NoVarList)
    /* Æ? */;

VarDeclList ::=
    (_VarDeclList)
    VarDeclList VarDecl
    |
    (NoVarDeclList)
    /* Æ? */;

ClassDecl ::=
    (ClassDeclValid)
    CLASS IDENT:ident Extends:E1 LBRACE VarDeclList:V2 ConstructorDeclAndMethodDeclListWrapper:C3 RBRACE {: RESULT=new ClassDeclValid(E1, V2, C3); RESULT.setLine(E1left); :}
    |
    (ClassDeclError)
    CLASS IDENT:ident EXTENDS error:l {: parser.report_error("SYNTAX ERROR: invalid EXTENDS syntax on line: " + lleft , null); :}
    LBRACE VarDeclList:V1 ConstructorDeclAndMethodDeclListWrapper:C2 RBRACE {: RESULT=new ClassDeclError(V1, C2); RESULT.setLine(V1left); :}
    ;

Extends ::=
    (_Extends)
    EXTENDS Type:ident
    |
    (NoExtends)
    /* Æ? */;

ConstructorDeclAndMethodDeclListWrapper ::=
    (_ConstructorDeclAndMethodDeclListWrapper)
    LBRACE ConstructorDeclAndMethodDeclList RBRACE
    |
    (NoConstructorDeclAndMethodDeclListWrapper)
    /* Æ? */;

ConstructorDeclAndMethodDeclList ::=
    (_ConstructorAndMethodDeclList)
    ConstructorDecl MethodDeclList
    |
    (MethodDeclListWithoutConstructorDecl)
    MethodDeclList;

ConstructorDecl ::=
    (_ConstructorDecl)
    IDENT:ident LPAREN RPAREN VarDeclList LBRACE StatementList RBRACE;

MethodDeclList ::=
    (_MethodDeclList)
    MethodDecl MethodDeclList
    |
    (NoMethodDeclList)
    /* Æ? */;

MethodDecl ::=
    (MethodDecl)
    TypeOrVoid:T1 IDENT:ident FormParsOrError:F2 VarDeclList:V3 LBRACE StatementList:S4 RBRACE {: RESULT=new MethodDecl(T1, F2, V3, S4); RESULT.setLine(T1left); :};

FormParsOrError ::=
    (FormPars)
    LPAREN FormPars:F1 RPAREN {: RESULT=new FormPars(F1); RESULT.setLine(F1left); :}
    |
    (FormParsErrorRPAREN)
    LPAREN error:l {: parser.report_error("SYNTAX ERROR: one or more invalid formal parameter declarations on line: " + lleft , null); :} RPAREN {: RESULT=new FormParsErrorRPAREN(); :}
    ;

FormPars ::=
    (MultipleFormPars)
    FormParList:F1 COMMA FormPar:F2 {: RESULT=new MultipleFormPars(F1, F2); RESULT.setLine(F1left); :}
    |
    (MultipleFormParsAndVarArgs)
    FormParList:F1 COMMA VarArgs:V2 {: RESULT=new MultipleFormParsAndVarArgs(F1, V2); RESULT.setLine(F1left); :}
    |
    (FormParsErrorCOMMA)
    error:l {: parser.report_error("SYNTAX ERROR: one or more invalid formal parameter declarations on line: " + lleft , null); :} COMMA {: RESULT=new FormParsErrorCOMMA(); :}
    |
    (SingleFormPar)
    FormPar:F1 {: RESULT=new SingleFormPar(F1); RESULT.setLine(F1left); :}
    |
    (SingleVarArg)
    VarArgs:V1 {: RESULT=new SingleVarArg(V1); RESULT.setLine(V1left); :}
    |
    (NoFormPars) {: RESULT=new NoFormPars(); :}
    /* Æ? */;

FormParList ::=
    (FormParListMultiple)
    FormParList:F1 COMMA FormPar:F2 {: RESULT=new FormParListMultiple(F1, F2); RESULT.setLine(F1left); :}
    |
    (FirstFormPar)
    FormPar:F1 {: RESULT=new FirstFormPar(F1); RESULT.setLine(F1left); :};

FormPar ::=
    (FormPar)
    Type:type IDENT:ident Brackets:B1 {: RESULT=new FormPar(type, B1); RESULT.setLine(typeleft); :};

VarArgs ::=
    (VarArgs)
    Type:type VARARGS IDENT:ident {: RESULT=new VarArgs(type); RESULT.setLine(typeleft); :};

StatementList ::=
    (_StatementList)
    StatementList Statement
    |
    (NoStatementList)
    /* Æ? */;

Statement ::=
    (MatchedStatement)
    MatchedStatement:M1 {: RESULT=new MatchedStatement(M1); RESULT.setLine(M1left); :}
    |
    (UnmatchedStatement)
    UnmatchedStatement:U1 {: RESULT=new UnmatchedStatement(U1); RESULT.setLine(U1left); :};

MatchedStatement ::=
    (MatchedIfStatement)
    IF ConditionOrError:C1 MatchedStatement:M2 ELSE MatchedStatement:M3 {: RESULT=new MatchedIfStatement(C1, M2, M3); RESULT.setLine(C1left); :}
    |
    (BodyStatement)
    LBRACE StatementList:S1 RBRACE {: RESULT=new BodyStatement(S1); RESULT.setLine(S1left); :}
    |
    (DesignatorStatement)
    Designator:D1 DesignatorOperation:D2 SEMICOLON {: RESULT=new DesignatorStatement(D1, D2); RESULT.setLine(D1left); :}
    |
    (DesignatorAssignStatementError)
    Designator:D1 Assignop:A2 error:l {: parser.report_info("SYNTAX ERROR: one or more invalid assign operations on line: " + lleft, null); :} SEMICOLON {: RESULT=new DesignatorAssignStatementError(D1, A2); RESULT.setLine(D1left); :}
    |
    (DoWhileStatement)
    DO StatementList:S1 WHILE LPAREN Condition:C2 RPAREN SEMICOLON {: RESULT=new DoWhileStatement(S1, C2); RESULT.setLine(S1left); :}
    |
    (BreakStatement)
    BREAK SEMICOLON {: RESULT=new BreakStatement(); :}
    |
    (ContinueStatement)
    CONTINUE SEMICOLON {: RESULT=new ContinueStatement(); :}
    |
    (ReturnStatement)
    RETURN ExprOrNothing:E1 SEMICOLON {: RESULT=new ReturnStatement(E1); RESULT.setLine(E1left); :}
    |
    (ReadStatement)
    READ LPAREN Designator:D1 RPAREN SEMICOLON {: RESULT=new ReadStatement(D1); RESULT.setLine(D1left); :}
    |
    (PrintStatement)
    PRINT LPAREN Expr:E1 NumConstList:N2 RPAREN SEMICOLON {: RESULT=new PrintStatement(E1, N2); RESULT.setLine(E1left); :};

UnmatchedStatement ::=
    (UnmatchedIfStatement)
    IF ConditionOrError:C1 Statement:S2 {: RESULT=new UnmatchedIfStatement(C1, S2); RESULT.setLine(C1left); :}
    |
    (UnmatchedIfElseStatement)
    IF ConditionOrError:C1 MatchedStatement:M2 ELSE UnmatchedStatement:U3 {: RESULT=new UnmatchedIfElseStatement(C1, M2, U3); RESULT.setLine(C1left); :};

ConditionOrError ::=
    (ConditionValid)
    LPAREN Condition:C1 RPAREN {: RESULT=new ConditionValid(C1); RESULT.setLine(C1left); :}
    |
    (ConditionError)
    LPAREN error:l {: parser.report_info("SYNTAX ERROR: one or more invalid assign operations on line: " + lleft, null); :} RPAREN {: RESULT=new ConditionError(); :};

DesignatorOperation ::=
    (DesignatorAssignOperation)
    Assignop:A1 Expr:E2 {: RESULT=new DesignatorAssignOperation(A1, E2); RESULT.setLine(A1left); :}
    |
    (DesignatorFuncCallOperation)
    LPAREN ActParsOrNothing:A1 RPAREN {: RESULT=new DesignatorFuncCallOperation(A1); RESULT.setLine(A1left); :}
    |
    (DesignatorIncOperation)
    INC {: RESULT=new DesignatorIncOperation(); :}
    |
    (DesignatorDecOperation)
    DEC {: RESULT=new DesignatorDecOperation(); :};

ActParsOrNothing ::=
    (ActPars)
    Expr:E1 ExprList:E2 {: RESULT=new ActPars(E1, E2); RESULT.setLine(E1left); :}
    |
    (NoActPars) {: RESULT=new NoActPars(); :}
    /* Æ? */;

ExprList ::=
    (_ExprList)
    ExprList COMMA Expr
    |
    (NoExprList)
    /* Æ? */;

ExprOrNothing ::=
    (ExprIndeed)
    Expr:E1 {: RESULT=new ExprIndeed(E1); RESULT.setLine(E1left); :}
    | {: RESULT=new ExprOrNothingDerived1(); :}
    /* Æ? */;

Designator ::=
    (DesignatorMemberReference)
    Designator:D1 DOT IDENT {: RESULT=new DesignatorMemberReference(D1); RESULT.setLine(D1left); :}
    |
    (DesignatorArrayReference)
    Designator:D1 LBRACKET Expr:E2 RBRACKET {: RESULT=new DesignatorArrayReference(D1, E2); RESULT.setLine(D1left); :}
    |
    (DesignatorIdent)
    IDENT:ident {: RESULT=new DesignatorIdent(); :};

Condition ::=
    (Condition)
    CondTerm:C1 OrCondTermList:O2 {: RESULT=new Condition(C1, O2); RESULT.setLine(C1left); :};

CondTerm ::=
    (CondTerm)
    CondFact:C1 AndCondFactList:A2 {: RESULT=new CondTerm(C1, A2); RESULT.setLine(C1left); :};

OrCondTermList ::=
    (_OrCondTermList)
    OrCondTermList OR CondTerm
    |
    (NoOrCondTermList)
    /* Æ? */;

AndCondFactList ::=
    (_AndCondFactList)
    AndCondFactList AND CondFact
    |
    (NoAndCondTermList)
    /* Æ? */;

CondFact ::=
    (ExprCondFact)
    Expr:E1 RelopExpr:R2 {: RESULT=new ExprCondFact(E1, R2); RESULT.setLine(E1left); :}
    |
    (InstanceOfCondFact)
    Designator:D1 INSTANCEOF Type:type {: RESULT=new InstanceOfCondFact(D1, type); RESULT.setLine(D1left); :};

RelopExpr ::=
    (_RelopExpr)
    Relop Expr
    |
    (NoRelopExpr)
    /* Æ? */;

Expr ::=
    (NegativeExpr)
    SUB Term:T1 AddopTermList:A2 {: RESULT=new NegativeExpr(T1, A2); RESULT.setLine(T1left); :}
    |
    (PositiveExpr)
    Term:T1 AddopTermList:A2 {: RESULT=new PositiveExpr(T1, A2); RESULT.setLine(T1left); :};

Term ::=
    (Term)
    Factor:F1 MulopFactorList:M2 {: RESULT=new Term(F1, M2); RESULT.setLine(F1left); :};

MulopFactorList ::=
    (_MulopFactorList)
    MulopFactorList Mulop Factor
    |
    (NoMulopFactorList)
    /* Æ? */;

Factor ::=
    (Factor)
    BaseExp:B1 ExpopBaseExpList:E2 {: RESULT=new Factor(B1, E2); RESULT.setLine(B1left); :};

ExpopBaseExpList ::=
    (_ExpopBaseExpList)
    ExpopBaseExpList Expop BaseExp
    |
    (NoExpopBaseExpList)
    /* Æ? */;

BaseExp ::=
    (BaseExpDesignator)
    Designator:D1 FuncCallOrNothing:F2 {: RESULT=new BaseExpDesignator(D1, F2); RESULT.setLine(D1left); :}
    |
    (BaseExpNumber)
    NUMBER {: RESULT=new BaseExpNumber(); :}
    |
    (BaseExpChar)
    CHAR {: RESULT=new BaseExpChar(); :}
    |
    (BaseExpBool)
    BOOL {: RESULT=new BaseExpBool(); :}
    |
    (BaseExpNewInstance)
    NEW Type:T1 BracketsWithExprOrNothing:B2 {: RESULT=new BaseExpNewInstance(T1, B2); RESULT.setLine(T1left); :}
    |
    (BaseExpExpr)
    LPAREN Expr:E1 RPAREN {: RESULT=new BaseExpExpr(E1); RESULT.setLine(E1left); :};

FuncCallOrNothing ::=
    (FuncCall)
    LPAREN ActParsOrNothing:A1 RPAREN {: RESULT=new FuncCall(A1); RESULT.setLine(A1left); :}
    |
    (NoFuncCall) {: RESULT=new NoFuncCall(); :}
    /* Æ? */;

BracketsWithExprOrNothing ::=
    (BracketsWithExpr)
    LBRACKET Expr:E1 RBRACKET {: RESULT=new BracketsWithExpr(E1); RESULT.setLine(E1left); :}
    |
    (NoBracketsWithExpr) {: RESULT=new NoBracketsWithExpr(); :}
    /* Æ? */;

AddopTermList ::=
    (_AddopTermList)
    AddopTermList Addop Term
    |
    (NoAddopTermList)
    /* Æ? */;

Addop ::=
    (Add)
    ADD {: RESULT=new Add(); :}
    |
    (Sub)
    SUB {: RESULT=new Sub(); :};

Assignop ::=
    (Assign)
    ASSIGN {: RESULT=new Assign(); :};

Relop ::=
    (Eq)
    EQ {: RESULT=new Eq(); :}
    |
    (Neq)
    NEQ {: RESULT=new Neq(); :}
    |
    (Gt)
    GT {: RESULT=new Gt(); :}
    |
    (Gte)
    GTE {: RESULT=new Gte(); :}
    |
    (Lt)
    LT {: RESULT=new Lt(); :}
    |
    (Lte)
    LTE {: RESULT=new Lte(); :};

Mulop ::=
    (Mul)
    MUL {: RESULT=new Mul(); :}
    |
    (Div)
    DIV {: RESULT=new Div(); :}
    |
    (Mod)
    MOD {: RESULT=new Mod(); :};

Expop ::=
    (Exp)
    EXP {: RESULT=new Exp(); :};

// TODO errors add gitignore